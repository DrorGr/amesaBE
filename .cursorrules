# AmesaBase Monorepo - Root Cursor Rules

## üöÄ Quick Reference (TL;DR)

**Essential Info**: .NET 8.0 Backend (8 microservices) + Angular Frontend | AWS ECS Fargate | Aurora PostgreSQL

| Item | Value |
|------|-------|
| **Context Version** | 2.7.0 |
| **Last Updated** | 2025-01-25 (‚ö†Ô∏è Verify deployment status before relying on claims) |
| **Backend Framework** | .NET 8.0, ASP.NET Core |
| **Database** | Aurora PostgreSQL Serverless v2 |
| **Infrastructure** | AWS (ECS Fargate, ECR, ALB, Aurora) |
| **Microservices** | 8 services (Auth, Lottery, Payment, Notification, Content, LotteryResults, Analytics, Admin) |
| **Frontend** | Angular 20.2.1 (FE/) |
| **Region** | eu-north-1 |
| **Status** | ‚úÖ Production operational |

**‚ö†Ô∏è CRITICAL**: Never pipe build commands directly - always use file-based output capture (see Agent Instructions)

**Quick Start**: Read this file ‚Üí BE/.cursorrules (delta) ‚Üí `MetaData/Documentation/README.md` ‚Üí Run `dotnet build` in `BE/` ‚Üí Verify deployment status

---

## Quick Status (2025-12-17)
- **Context Version**: 2.7.0 (supersedes prior 2.6.0/2.5.x references)
- **Staleness Warning**: Content last fully updated 2025-01-25; changes between 2025-01-25 and 2025-12-17 not captured. Verify deployment state, health checks, and "production-ready" claims before relying.
- **Known Gap**: No log of work after multi-channel notifications/payment/favorites fixes. Add recent releases, incidents, and infra changes when known.
- **Outdated Sections**: Rate limit table, background service lists, dependency versions, "Latest Session" - verify before relying.

## Project Overview
AmesaBE is the backend API for the Amesa lottery management system. Built with .NET 8.0 and ASP.NET Core, it provides RESTful APIs, real-time communication via SignalR, and integrates with Aurora PostgreSQL for data persistence.

**‚ö†Ô∏è This repository is part of the AmesaBase-Monorepo workspace**
- **Monorepo Root**: `C:\Users\dror0\Curser-Repos\AmesaBase-Monorepo\`
- **Frontend (FE/)**: Angular frontend ‚Üí https://github.com/DrorGr/amesaFE
- **Backend (BE/)**: .NET 8.0 backend ‚Üí https://github.com/DrorGr/amesaBE
- **MetaData/**: Cross-cutting docs, scripts, and configs

## Repository Structure

### Microservice Projects (8 Services + Supporting Projects)

| Service | ECS Service | Schema | Key Features |
|---------|-------------|--------|--------------|
| **AmesaBackend.Auth** | `amesa-auth-service` | `amesa_auth` | JWT auth, OAuth (Google, Meta), ID verification, user preferences |
| **AmesaBackend.Lottery** | `amesa-lottery-service` | `amesa_lottery` | Houses, tickets, draws, watchlist, participant caps |
| **AmesaBackend.Payment** | `amesa-payment-service` | `amesa_payment` | Stripe integration, products, transactions, payment methods |
| **AmesaBackend.Notification** | `amesa-notification-service` | `amesa_notification` | Email, SMS, WebPush, Telegram, notification preferences |
| **AmesaBackend.Content** | `amesa-content-service` | `amesa_content` | Translations, content management, languages |
| **AmesaBackend.LotteryResults** | `amesa-lottery-results-service` | `amesa_lottery_results` | Draw results, QR codes, prize delivery |
| **AmesaBackend.Analytics** | `amesa-analytics-service` | `amesa_analytics` | User sessions, activity logs, analytics tracking |
| **AmesaBackend.Admin** | `amesa-admin-service` | `amesa_admin` | Admin dashboard, houses/users management, real-time updates, ‚úÖ Production-ready |

**Admin Panel Details**: Blazor Server, Rate limiting (5 attempts, 30-min lockout), Redis-backed sessions (2-hour timeout), S3 image uploads, CloudWatch logging

### Supporting Projects
- **AmesaBackend.Shared** - Shared library for all microservices
  - Contains: Authentication, Caching, Events, Middleware, Models, REST clients, Extensions
  - Used by: All microservices
  - Key Components:
    - Authentication: JWT token management, cryptography
    - Caching: Redis cache abstraction (ICache interface)
    - Events: EventBridge publisher for event-driven architecture
    - Middleware: Error handling, logging, security headers, service-to-service auth
    - Contracts: ApiResponse, ApiException, validation errors
    - REST: HTTP request service for inter-service communication
    - Tracing: AWS X-Ray integration

- **AmesaBackend.Lottery.Design** - EF Core design-time tooling
  - Purpose: Entity Framework migrations tooling for Lottery service
  - Not deployed as a service

- **AmesaBackend.Tests** - Unit and integration tests
  - Test Framework: xUnit with FluentAssertions, Bogus, AutoFixture
  - Coverage: Unit tests, integration tests, security tests
  - Test Helpers: InMemoryCache, TestDataBuilder, WebApplicationFixture

- **AmesaBackend.DatabaseSeeder** - Database seeding tool
  - Status: Excluded from repository (in .gitignore)
  - Purpose: Manual database seeding for test data

- **AmesaBackend** - Legacy main project (may contain shared code)
  - Note: Some services may reference this for shared models/services

### Related Repositories
- **amesaFE**: Frontend (Angular) ‚Üí https://github.com/DrorGr/amesaFE
- **amesaDevOps**: Infrastructure as Code repository

### Scripts and Infrastructure
- **Scripts**: All SQL and PowerShell scripts in `MetaData/Scripts/` folder
- **Infrastructure**: Terraform, deployment scripts in `BE/Infrastructure/`

## Technology Stack

| Category | Technology |
|----------|-----------|
| **Backend Framework** | .NET 8.0, ASP.NET Core, Entity Framework Core |
| **Admin Panel** | Blazor Server (integrated monolith) ‚úÖ |
| **Database** | Aurora PostgreSQL Serverless v2 (prod), SQLite (local dev) |
| **Real-time** | SignalR for live lottery updates |
| **Authentication** | JWT Bearer tokens (API), Email/Password (Admin Panel) |
| **Payment** | Stripe integration |
| **Caching** | Redis (StackExchange.Redis v2.7.33) - Required for Auth, Lottery, Content, Payment |
| **Infrastructure** | AWS (ECS Fargate, ECR, ALB, Aurora) |
| **CI/CD** | GitHub Actions |
| **Package Management** | NuGet |

## Database Schemas
All microservices use PostgreSQL schemas for data isolation:

| Schema | Service | Key Tables/Views |
|--------|---------|-----------------|
| **amesa_auth** | Auth | users, user_sessions, user_preferences, user_identity_documents, system_configurations |
| **amesa_lottery** | Lottery | houses, house_images, lottery_tickets, lottery_draws, user_watchlist, ticket_reservations, **view**: lottery_participants |
| **amesa_payment** | Payment | transactions, user_payment_methods, products, product_links, transaction_items, payment_audit_logs |
| **amesa_notification** | Notification | user_notifications, notification_templates, notification_deliveries, user_channel_preferences, push_subscriptions, telegram_user_links, notification_queue, notification_types |
| **amesa_content** | Content | translations, languages, content, content_categories, content_media |
| **amesa_lottery_results** | LotteryResults | lottery_results, lottery_result_history, prize_deliveries |
| **amesa_analytics** | Analytics | user_sessions, user_activity_logs |
| **amesa_admin** | Admin | admin_users, admin_sessions, audit_logs |
| **public** | Shared | Some shared tables (e.g., translations may use public schema) |

## External Service Integrations

| Category | Service/Package | Version | Purpose |
|----------|----------------|---------|---------|
| **AWS Services** | AWS Rekognition | v3.7.400 | ID verification, face detection, OCR |
| | AWS SES | - | Email delivery for notifications |
| | AWS SNS | - | SMS notifications and mobile push |
| | AWS Secrets Manager | v3.7.400 | Secure credential storage |
| | AWS S3 | v3.7.400 | File storage |
| | AWS EventBridge | v3.7.400 | Event-driven architecture |
| | AWS X-Ray | - | Distributed tracing |
| **Payment** | Stripe | - | Payment processing (via StripeService) |
| **Authentication** | Google OAuth | v8.0.0 | Google sign-in |
| | Meta/Facebook OAuth | v8.0.0 | Facebook sign-in |
| | Google reCAPTCHA Enterprise | v2.2.0 | Bot protection |
| **Real-time** | SignalR | - | WebSocket/LongPolling (LotteryHub, NotificationHub) |
| **Notifications** | Telegram Bot API | - | Telegram notification channel |
| | WebPush API | - | Browser push notifications |
| **Utilities** | QRCoder | v1.6.0 | QR code generation |
| | Otp.NET | v1.3.0 | Two-factor authentication |
| | Polly | v8.4.2 | Resilience and retry policies |
| | AutoMapper | v12.0.1 | Object-to-object mapping |
| | BCrypt.Net-Next | v4.0.3 | Password hashing |
| | Serilog | v8.0.0 | Structured logging |

## Key Dependencies

| Category | Package | Version | Purpose |
|----------|---------|---------|---------|
| **Core Framework** | Microsoft.AspNetCore.OpenApi | v8.0.0 | OpenAPI/Swagger support |
| | Microsoft.EntityFrameworkCore | v8.0.0 | ORM |
| | Microsoft.EntityFrameworkCore.Design | v8.0.0 | EF Core tooling |
| | Npgsql.EntityFrameworkCore.PostgreSQL | v8.0.0 | PostgreSQL provider |
| | Microsoft.AspNetCore.Authentication.JwtBearer | v8.0.0 | JWT authentication |
| **Shared Library** | StackExchange.Redis | v2.7.33 | Redis client |
| | Microsoft.Extensions.Caching.StackExchangeRedis | v8.0.0 | Redis caching |
| | System.IdentityModel.Tokens.Jwt | v7.0.3 | JWT token handling |
| | Microsoft.IdentityModel.Tokens | v7.0.3 | Token validation |
| | Newtonsoft.Json | v13.0.3 | JSON serialization |
| | Serilog | suite | Structured logging |

## Current Status (2025-01-25)

| Area | Status | Details |
|------|--------|---------|
| **Repository** | ‚úÖ Stable | https://github.com/DrorGr/amesaBE, Main branch deployed |
| **Completion** | ‚úÖ **100% COMPLETE** | All development work, gap fixes, integration tasks done (see `BE/100_PERCENT_COMPLETE_AUDIT.md`) |
| **Admin Panel** | ‚úÖ Production | Blazor Server deployed, all critical security issues fixed |
| **Auth Security** | ‚úÖ Complete | Final deep audit complete, all critical/high-priority issues resolved |
| **OAuth** | ‚úÖ Ready | Meta/Facebook OAuth integrated with AWS Secrets Manager |
| **Notifications** | ‚úÖ Deployed | Multi-channel system production-ready, ALB routing configured |
| **Database** | ‚úÖ Seeded | Comprehensive test data, 4 languages (EN, ES, FR, PL) - 507 keys each |
| **Services** | ‚úÖ Operational | All 8 microservices running, Redis required for Auth/Lottery/Content/Payment |
| **Tests** | ‚úÖ Passing | 97 passed, 0 failed, 5 skipped (failures don't block deployment) |
| **Deployment** | ‚úÖ Fixed | ECS deployment issues resolved, SSM parameters configured |

## Environment Configuration

| Environment | Backend | Database | Admin Panel | Config File |
|------------|---------|----------|-------------|-------------|
| **Local Dev** | http://localhost:5000 | SQLite (AmesaDB.db) or local PostgreSQL | http://localhost:5000/admin | `appsettings.Development.json` |
| **Production** | amesa-backend-alb-509078867.eu-north-1.elb.amazonaws.com | amesadbmain (Aurora PostgreSQL Serverless v2) | http://amesa-backend-alb-509078867.eu-north-1.elb.amazonaws.com/admin ‚úÖ | ECS task definition |
| **ECS Cluster** | Amesa | - | - | - |
| **ECR Tags** | prod-{sha}, latest, prod-latest | - | - | - |
| **Deployment** | Auto on push to main | - | - | - |

## AWS Infrastructure

**Note**: See root `.cursorrules` for complete infrastructure summary.

- **Region**: eu-north-1 (Stockholm)
- **Account**: 129394705401
- **ECR Repository**: amesabe
- **ECS Cluster**: Amesa
- **Aurora PostgreSQL**: Serverless v2 production cluster
- **ALB**: Application Load Balancer for production
- **CloudWatch**: Logs and monitoring

## API Structure

### Core Endpoints
- **Health**: `/health` - Service health check (all services)
- **Auth**: `/api/v1/auth/*` - Authentication and user management (amesa-auth-service)
- **OAuth**: `/api/v1/oauth/*` - OAuth authentication (Google, Meta) (amesa-auth-service)
- **Houses**: `/api/v1/houses/*` - Lottery properties and tickets (amesa-lottery-service)
- **Tickets**: `/api/v1/tickets/*` - Lottery ticket operations (amesa-lottery-service)
- **Lottery**: `/api/v1/lottery/*` - Lottery operations (amesa-lottery-service)
- **Translations**: `/api/v1/translations/*` - Internationalization (amesa-content-service)
- **Content**: `/api/v1/content/*` - Content management (amesa-content-service)
- **Lottery Results**: `/api/v1/lottery-results/*` or `/api/v1/lotteryresults/*` - Draw results (amesa-lottery-results-service)
- **Notifications**: `/api/v1/notifications/*` - User notifications (mark as read, delete) (amesa-notification-service) ‚úÖ NEW
- **Payments**: `/api/v1/payment/*` or `/api/v1/payments/*` - Payment processing (amesa-payment-service)
- **Products**: `/api/v1/products/*` - Product management (amesa-payment-service)
- **Analytics**: `/api/v1/analytics/*` - Analytics tracking (amesa-analytics-service)
- **Admin Panel**: `/admin/*` - Blazor Server admin interface (amesa-admin-service)
- **Admin SignalR Hub**: `/admin/hub` - AdminHub for real-time notifications (amesa-admin-service)
- **Blazor SignalR**: `/_blazor/*` - Blazor Server framework SignalR hub (amesa-admin-service)

### OAuth Endpoints
- **Google OAuth**: 
  - `GET /api/v1/oauth/google` - Initiate Google OAuth login
  - `GET /api/v1/oauth/google-callback` - Google OAuth callback handler
- **Meta OAuth**: 
  - `GET /api/v1/oauth/meta` - Initiate Meta/Facebook OAuth login
  - `GET /api/v1/oauth/meta-callback` - Meta OAuth callback handler
- **Token Exchange**: 
  - `POST /api/v1/oauth/exchange` - Exchange temporary OAuth code for JWT tokens (shared by all providers)

### Admin Panel ‚úÖ

| Aspect | Details |
|--------|---------|
| **URL** | `/admin` - Blazor Server admin interface |
| **ECS Service** | `amesa-admin-service` |
| **Technology** | Blazor Server (.NET 8.0), Port 8080 (HTTP) |
| **Database Schema** | `amesa_admin` (admin_users, admin_sessions, audit_logs) |
| **Authentication** | Email/password, Redis-backed sessions (2-hour timeout, in-memory fallback) |
| **Security** | ‚úÖ Rate limiting (5 attempts, 30-min lockout), BCrypt hashing, HTTPS-only cookies, page-level auth |
| **Features** | Dashboard, Houses CRUD, Users management, Database selector, S3 image upload, Real-time SignalR |
| **Pages** | `/login`, `/logout`, `/dashboard`, `/houses/*`, `/users/*`, `/tickets`, `/draws`, `/payments`, `/translations` |
| **SignalR Hub** | `AdminHub` at `/admin/hub`, Groups: `houses`, `users`, `draws`, Events: `HouseCreated/Updated/Deleted`, `UserUpdated`, `DrawConducted` |
| **Key Services** | AdminAuthService, AdminDatabaseService, DashboardService, HousesService, UsersService, TranslationsService, S3ImageService, CloudWatchLoggingService, RealTimeNotificationService (all Scoped) |
| **AWS Integration** | S3 (bucket: `amesa-house-images-prod`), CloudWatch logging |
| **Documentation** | `MetaData/Documentation/Development/ADMIN_SERVICE_HANDOFF.md`, `ADMIN_SERVICE_CODE_REVIEW_AUDIT.md` |

### Real-time Hubs (SignalR)

- **AdminHub** (`/admin/hub`):
  - **Service**: `amesa-admin-service`
  - **Location**: `BE/AmesaBackend.Admin/Hubs/AdminHub.cs`
  - **Events Broadcasted**:
    - `HouseCreated` - New house created notification
    - `HouseUpdated` - House updated notification
    - `HouseDeleted` - House deleted notification
    - `UserUpdated` - User updated notification
    - `DrawConducted` - Draw conducted notification
  - **Groups**: `houses`, `users`, `draws` (whitelist validation)
  - **Methods**: `JoinGroup(string groupName)`, `LeaveGroup(string groupName)`
  - **Authorization**: No explicit `[Authorize]` attribute (relies on page-level auth via `AuthorizedPageBase`)
  - **Transport**: LongPolling (CloudFront compatibility)
  - **Client Script**: `wwwroot/js/admin-signalr.js` (with retry logic, initialization guards, 500ms delay)

- **LotteryHub** (`/ws/lottery`):
  - **Service**: `amesa-lottery-service`
  - **Location**: `BE/AmesaBackend.Lottery/Hubs/LotteryHub.cs`
  - **Events Broadcasted**:
    - `OnLotteryUpdate` - House status, ticket sales, participation updates
    - `OnFavoriteUpdate` - Watchlist changes (added/removed)
    - `OnEntryStatusChange` - Ticket entry status changes
    - `OnDrawReminder` - Lottery draw countdown reminders
    - `OnRecommendation` - House recommendations
    - `InventoryUpdated` - Real-time ticket inventory updates
    - `TicketPurchased` - Ticket purchase notifications
    - `CountdownUpdated` - Lottery countdown updates
    - `LotteryDrawStarted` - Draw start notifications
    - `LotteryDrawCompleted` - Draw completion notifications
  - **User Groups**: Automatically managed in `OnConnectedAsync()` based on user ID
  - **Authorization**: `[Authorize]` attribute (JWT Bearer token required)
  - **Transport**: LongPolling (CloudFront compatibility, WebSocket not supported)
  
- **NotificationHub** (`/ws/notifications`):
  - **Service**: `amesa-notification-service`
  - **Location**: `BE/AmesaBackend.Notification/Hubs/NotificationHub.cs`
  - **Events Broadcasted**:
    - `OnNotification` - User notifications (email, SMS, WebPush, Telegram)
    - `OnUserStatusUpdate` - User online/offline status
  - **User Groups**: Automatically managed in `OnConnectedAsync()` based on user ID
  - **Authorization**: `[Authorize]` attribute (JWT Bearer token required)
  - **Transport**: LongPolling (CloudFront compatibility, WebSocket not supported)
  
- **Connection Configuration**:
  - **CloudFront Timeout**: 60 seconds (OriginReadTimeout) for LongPolling support
  - **ALB Routing**: 
    - Priority 5: `/ws/lottery/*` ‚Üí `amesa-lottery-service-tg`
    - Priority 6: `/ws/notifications/*` ‚Üí `amesa-notification-service-tg`
  - **Reconnection**: Automatic with exponential backoff (frontend handles)

### API Versioning Strategy
- **Current Version**: `v1` (all endpoints use `/api/v1/` prefix)
- **Versioning Approach**: URL path versioning (e.g., `/api/v1/user/preferences`, `/api/v1/auth/login`)
- **Backward Compatibility**: Breaking changes require new version (e.g., `v2`)
- **Deprecation Policy**: 
  - Old versions maintained for a grace period
  - Deprecation warnings in response headers when applicable
- **Route Attribute**: `[Route("api/v1/...")]` on controllers
- **Example**: `[Route("api/v1/user/[controller]")]` on `UserPreferencesController`

## Coding Standards

### .NET/C# Best Practices
- Use .NET 8.0 features and patterns
- Follow async/await patterns for all I/O operations
- Implement proper dependency injection
- Use Entity Framework Core with migrations
- Follow RESTful API design principles
- Implement comprehensive error handling
- Use structured logging with Serilog

### API Design
- Versioned endpoints (`/api/v1/`)
- Consistent response format (success/error wrapping)
- Proper HTTP status codes
- Request/response DTOs for all endpoints
- Swagger/OpenAPI documentation
- Input validation with FluentValidation
- Rate limiting and throttling

### Security
- JWT Bearer authentication (Microsoft.AspNetCore.Authentication.JwtBearer v8.0.0)
- Role-based authorization
- CORS configuration
- Security headers middleware (SecurityHeadersMiddleware in Shared)
- Input sanitization
- SQL injection prevention (parameterized queries, EF Core)
- Secrets management via AWS Secrets Manager
- Service-to-service authentication (ServiceToServiceAuthMiddleware)
  - API key stored in SSM Parameter Store: `/amesa/prod/ServiceAuth/ApiKey`
- Account lockout and rate limiting
- Password breach checking
- Refresh token rotation
- Session management with device tracking
- OAuth token caching
- reCAPTCHA Enterprise integration

### Database
- PostgreSQL in production (Aurora Serverless v2)
- SQLite for local development
- Entity Framework Core migrations
- Connection pooling and retry logic
- Database seeding for initial data (manual via DatabaseSeeder)
- **Schema Organization**: Each microservice uses its own PostgreSQL schema
  - Schemas: amesa_auth, amesa_lottery, amesa_payment, amesa_notification, amesa_content, amesa_lottery_results, amesa_analytics
- **Database Contexts**: Each service has its own DbContext
  - AuthDbContext (amesa_auth schema)
  - LotteryDbContext (amesa_lottery schema)
  - PaymentDbContext (amesa_payment schema)
  - NotificationDbContext (amesa_notification schema)
  - ContentDbContext (amesa_content schema)
  - LotteryResultsDbContext (amesa_lottery_results schema)
  - AnalyticsDbContext (amesa_analytics schema) (manual via DatabaseSeeder)

### Code Patterns and Conventions
- **Naming Conventions**:
  - Controllers: PascalCase with "Controller" suffix (e.g., `AuthController`)
  - Services: PascalCase with "Service" suffix (e.g., `AuthService`)
  - Interfaces: PascalCase with "I" prefix (e.g., `IAuthService`)
  - DTOs: PascalCase with "Dto" suffix (e.g., `LoginRequestDto`)
  - Models: PascalCase (e.g., `User`, `LotteryTicket`)
- **File Organization**:
  - One class per file
  - Match file name to class name
  - Organize by feature/domain (Controllers/, Services/, Models/, DTOs/)
- **Dependency Injection**:
  - Use constructor injection
  - Register services in `Program.cs` or configuration classes
  - Prefer interfaces over concrete types
- **Async/Await**:
  - Use `async Task` or `async Task<T>` for all I/O operations
  - Avoid `async void` (except event handlers)
  - Use `ConfigureAwait(false)` in library code
- **Error Handling**:
  - Use `ApiResponse<T>` wrapper for all API responses
  - Throw `ApiException` for business logic errors
  - Use middleware for global error handling
- **Logging**:
  - Use Serilog for structured logging
  - Log levels: Debug, Information, Warning, Error, Fatal
  - Include correlation IDs for request tracing
- **API Design**:
  - RESTful endpoints with `/api/v1/` prefix
  - Use HTTP verbs correctly (GET, POST, PUT, DELETE)
  - Return appropriate HTTP status codes
  - Include XML documentation comments
- **Security**:
  - Use `[Authorize]` attributes on controllers/actions
  - Validate all input with Data Annotations or FluentValidation
  - Use parameterized queries (EF Core handles this)
  - Never log sensitive data (passwords, tokens, PII)

## Key Configuration Files
Each microservice has its own set of configuration files:

### Application Configuration
- **`appsettings.json`** - Base configuration (one per service)
  - Connection strings, AWS settings, service URLs
  - Environment variables injected at runtime
- **`appsettings.Development.json`** - Development configuration
  - Local database connections
  - Development service URLs
  - Debug logging settings
- **`Program.cs`** - Service startup and dependency injection
  - Each service has its own Program.cs
  - Configuration extracted to dedicated classes (e.g., `AuthenticationConfiguration.cs`, `ServiceConfiguration.cs`)
  - Middleware registration
  - Health check endpoints
  - SignalR hub registration (where applicable)

### Database Configuration
- **DbContext Classes** - Database context configuration (one per service)
  - `AmesaBackend.Auth/Data/AuthDbContext.cs` - Auth service (amesa_auth schema)
  - `AmesaBackend.Lottery/Data/LotteryDbContext.cs` - Lottery service (amesa_lottery schema)
  - `AmesaBackend.Payment/Data/PaymentDbContext.cs` - Payment service (amesa_payment schema)
  - `AmesaBackend.Notification/Data/NotificationDbContext.cs` - Notification service (amesa_notification schema)
  - `AmesaBackend.Content/Data/ContentDbContext.cs` - Content service (amesa_content schema)
  - `AmesaBackend.LotteryResults/Data/LotteryResultsDbContext.cs` - Lottery results service (amesa_lottery_results schema)
  - `AmesaBackend.Analytics/Data/AnalyticsDbContext.cs` - Analytics service (amesa_analytics schema)
  - Each DbContext uses schema-specific connection strings and retry policies

### Container Configuration
- **`Dockerfile`** - Container build configuration (one per service)
  - `AmesaBackend.Auth/Dockerfile`
  - `AmesaBackend.Lottery/Dockerfile`
  - `AmesaBackend.Payment/Dockerfile`
  - `AmesaBackend.Notification/Dockerfile`
  - `AmesaBackend.Content/Dockerfile`
  - `AmesaBackend.LotteryResults/Dockerfile`
  - `AmesaBackend.Analytics/Dockerfile`
  - `AmesaBackend.Admin/Dockerfile`
  - Base image: `mcr.microsoft.com/dotnet/aspnet:8.0`
  - Multi-stage builds for optimization
  - Port: 8080 (HTTP)
  - Non-root user: `app` for security

### Deployment Configuration
- **ECS Task Definitions** - Service deployment configuration
  - Located in `BE/Infrastructure/` or AWS ECS console
  - Each service has its own task definition
  - Environment variables injected from AWS Parameter Store
  - Secrets from AWS Secrets Manager
  - Health check configuration
- **GitHub Workflows** - CI/CD configuration
  - `BE/.github/workflows/build-and-deploy.yml` - Main deployment workflow
    - Builds all 8 microservices
    - Pushes Docker images to ECR
    - Deploys to ECS Fargate
  - `BE/.github/workflows/test.yml` - Test workflow
    - Runs unit and integration tests
    - Code quality checks

### Shared Configuration
- **`AmesaBackend.Shared/`** - Shared library configuration
  - Common DTOs, interfaces, middleware
  - AWS SDK configurations
  - Redis cache configuration
  - EventBridge publisher configuration
  - JWT token validation configuration

## Project Structure Guidelines

### Controllers
- Thin controllers, business logic in services
- Action-level authorization attributes
- Comprehensive XML documentation comments
- Proper model validation

### Services
- Interface-based service pattern (IServiceName interfaces)
- Scoped/Singleton lifetime management
- Async methods for I/O operations
- Dependency injection
- **Service Organization**: Each microservice has its own Services folder
  - Services implement interfaces (IServiceName pattern)
  - Services handle business logic
  - Services use DbContext for data access
  - Services can call other services via HTTP (HttpRequestService) or EventBridge
  - **Shared Services**: Common services in AmesaBackend.Shared
    - JwtTokenManager - JWT token generation/validation
    - StackRedisCache - Redis caching abstraction
    - EventBridgePublisher - Event publishing
    - HttpRequestService - Inter-service HTTP communication

### DTOs
- Separate request/response models
- AutoMapper for entity mapping
- Validation attributes

### Middleware
- Error handling middleware (global exception handler) - ErrorHandlerMiddleware
- Request logging middleware - RequestResponseLoggingMiddleware, AMESASerilogScopedLoggingMiddleware
- Security headers middleware - SecurityHeadersMiddleware
- Authentication/authorization middleware - JWT Bearer, ServiceToServiceAuthMiddleware
- **Middleware Location**: Shared middleware in `AmesaBackend.Shared/Middleware/`
  - ErrorHandling/ErrorHandlerMiddleware.cs
  - Logging/RequestResponseLoggingMiddleware.cs
  - Logging/AMESASerilogScopedLoggingMiddleware.cs
  - SecurityHeadersMiddleware.cs
  - ServiceToServiceAuthMiddleware.cs
- **Service-Specific Middleware**: Some services have their own middleware
  - Auth: OriginHeaderValidationMiddleware, EmailVerificationMiddleware, SecurityAuditMiddleware, IpTrackingMiddleware, SessionActivityMiddleware

## Docker Configuration
- **Base Image**: mcr.microsoft.com/dotnet/aspnet:8.0
- **Port**: 8080 (HTTP)
- **Health Check**: `/health` endpoint (all services)
- **Non-root user**: app user for security
- **Multi-stage build**: Separate build and runtime stages
- **Dockerfiles**: Each microservice has its own Dockerfile
  - `AmesaBackend.Auth/Dockerfile`
  - `AmesaBackend.Lottery/Dockerfile`
  - `AmesaBackend.Payment/Dockerfile`
  - `AmesaBackend.Notification/Dockerfile`
  - `AmesaBackend.Content/Dockerfile`
  - `AmesaBackend.LotteryResults/Dockerfile`
  - `AmesaBackend.Analytics/Dockerfile`
  - `AmesaBackend.Admin/Dockerfile`

## Deployment Flow

### Automatic Deployment
1. **Main Branch** ‚Üí Push ‚Üí GitHub Actions ‚Üí ECR ‚Üí ECS Production

### Deploying Specific Services
**IMPORTANT**: You can deploy individual services without deploying all services.

**When to use**:
- When you only changed one service (e.g., `AmesaBackend.Lottery`)
- When you want faster deployments
- When you want to avoid redeploying unrelated services

**How to deploy a specific service**:

**Option 1: Using PowerShell Script (Recommended)**
```powershell
cd BE/Infrastructure
.\deploy-specific-service.ps1 -ServiceName "amesa-lottery-service"
```

**Available Services**:
- `amesa-auth-service` ‚Üí `AmesaBackend.Auth`
- `amesa-content-service` ‚Üí `AmesaBackend.Content`
- `amesa-notification-service` ‚Üí `AmesaBackend.Notification`
- `amesa-payment-service` ‚Üí `AmesaBackend.Payment`
- `amesa-lottery-service` ‚Üí `AmesaBackend.Lottery`
- `amesa-lottery-results-service` ‚Üí `AmesaBackend.LotteryResults`
- `amesa-analytics-service` ‚Üí `AmesaBackend.Analytics`
- `amesa-admin-service` ‚Üí `AmesaBackend.Admin`

**Option 2: Manual AWS CLI Commands**
```bash
# 1. Build and push Docker image
cd BE
docker build -f AmesaBackend.Lottery/Dockerfile -t 129394705401.dkr.ecr.eu-north-1.amazonaws.com/amesa-lottery-service:latest .
aws ecr get-login-password --region eu-north-1 | docker login --username AWS --password-stdin 129394705401.dkr.ecr.eu-north-1.amazonaws.com
docker push 129394705401.dkr.ecr.eu-north-1.amazonaws.com/amesa-lottery-service:latest

# 2. Force ECS service update
aws ecs update-service --cluster Amesa --service amesa-lottery-service --force-new-deployment --region eu-north-1
```

**Option 3: GitHub Actions with Path Filters**
- GitHub Actions workflows can be configured to only trigger on changes to specific paths
- Example: Only deploy lottery service when `AmesaBackend.Lottery/**` files change
- See workflow files for path filter configuration

**Benefits of Service-Specific Deployment**:
- ‚úÖ Faster deployments (only build/push one service)
- ‚úÖ Reduced risk (don't affect other services)
- ‚úÖ Lower resource usage (smaller Docker builds)
- ‚úÖ Easier debugging (isolated service updates)

### GitHub Secrets Required
- `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`
- `PROD_ECS_CLUSTER` (Amesa)
- `PROD_DB_CONNECTION_STRING`
- `PROD_JWT_SECRET_KEY`
- **Note**: ECS services are deployed individually, not as a single service
- **ECR Repository**: `amesabe` (shared repository for all services)
- **Image Tags**: `prod-{sha}`, `latest`, `prod-latest`

## Common Commands

### Local Development
```bash
# Restore dependencies
dotnet restore

# Build solution
dotnet build

# Run tests
dotnet test

# Run application
dotnet run --project AmesaBackend

# Run with database seeding
dotnet run --project AmesaBackend -- --seeder

# Watch mode (auto-reload)
dotnet watch run --project AmesaBackend
```

### Database Operations
```bash
# Add migration
dotnet ef migrations add MigrationName --project AmesaBackend

# Update database
dotnet ef database update --project AmesaBackend

# Rollback migration
dotnet ef database update PreviousMigrationName --project AmesaBackend

# Generate SQL script
dotnet ef migrations script --project AmesaBackend
```

### Migration Patterns
- **EF Core Migrations**:
  - **Generation**: `dotnet ef migrations add <MigrationName> --project <ProjectName>`
  - **Application**: `dotnet ef database update --project <ProjectName>`
  - **Location**: `Migrations/` folder in each service project (e.g., `BE/AmesaBackend.Auth/Migrations/`)
  - **Naming**: Timestamp-based (e.g., `20251115215123_InitialCreate.cs`)
  - **Files**: Migration class, Designer file, and ModelSnapshot
- **Manual SQL Migrations**:
  - **Use Case**: Complex migrations, data transformations, or schema changes requiring manual SQL
  - **Location**: `Infrastructure/DatabaseSetup/` or service-specific migration scripts
  - **Execution**: Via `DatabaseSetup` project or direct SQL execution
- **Production Migration Checklist**:
  - Backup database before migration
  - Test migration on staging environment
  - Review generated SQL script (`dotnet ef migrations script`)
  - Apply migration during maintenance window if required
  - Verify migration success and rollback plan

### Docker Operations
```bash
# Build Docker image
docker build -t amesa-backend:dev ./AmesaBackend

# Run Docker container
docker run -p 8080:8080 amesa-backend:dev

# Docker Compose (development)
docker-compose -f docker-compose.dev.yml up

# Docker Compose (production-like)
docker-compose up
```

### AWS Operations
```bash
# List ECS services
aws ecs list-services --cluster Amesa --region eu-north-1

# Describe specific ECS service
aws ecs describe-services --cluster Amesa --services amesa-auth-service --region eu-north-1
aws ecs describe-services --cluster Amesa --services amesa-lottery-service --region eu-north-1

# View service logs (service-specific log groups)
aws logs tail /ecs/amesa-auth-service --follow --region eu-north-1
aws logs tail /ecs/amesa-lottery-service --follow --region eu-north-1

# List ECR images
aws ecr describe-images --repository-name amesabe --region eu-north-1

# Database cluster info
aws rds describe-db-clusters --db-cluster-identifier amesadbmain --region eu-north-1
```

### Git Operations
```bash
# Check status
git status

# View recent commits
git log --oneline -5

# Switch to main branch
git checkout main
```

### Testing Patterns
- **Framework**: xUnit for all backend tests
- **Test Organization**:
  - **Unit Tests**: Test individual services, repositories, and business logic in isolation
  - **Integration Tests**: Test service interactions, database operations, and external integrations
  - **Security Tests**: Test authentication, authorization, rate limiting, and security headers
  - **Location**: `BE/AmesaBackend.Tests/` with subdirectories for test types
- **Test Helpers**:
  - **TestDataBuilder**: Fluent builder pattern for creating test data (User, House, LotteryTicket)
    - Uses `Bogus` library for fake data generation
    - Location: `BE/AmesaBackend.Tests/TestHelpers/TestDataBuilder.cs`
    - Example: `TestDataBuilder.User().WithEmail("test@example.com").Build()`
  - **InMemoryCache**: In-memory implementation of `ICache` interface for testing
    - Replaces Redis in tests
    - Location: `BE/AmesaBackend.Tests/TestHelpers/InMemoryCache.cs`
    - Uses `ConcurrentDictionary` with expiration logic
  - **WebApplicationFixture**: Test fixture for integration tests with in-memory database
- **Mocking Strategy**:
  - **Framework**: Moq for mocking interfaces and dependencies
  - **In-Memory Database**: SQLite in-memory for integration tests (replaces PostgreSQL)
  - **Mock Services**: External services (SNS, SES, Stripe, etc.) are mocked in unit tests
- **Test Data**:
  - **Fake Data**: Bogus library for generating realistic test data
  - **Builders**: Fluent builder pattern for complex object creation
  - **Fixtures**: Reusable test data fixtures for common scenarios

## Context Files to Maintain

### In This Repository (BE/):
- Note: Repository-specific context files are optional. Current status is maintained in `.cursorrules`.
- `README.md` - Project documentation (if exists)

### In Monorepo MetaData/ (Cross-cutting):
- `../MetaData/Documentation/AWS_INFRASTRUCTURE_DETAILS.md` - Infrastructure details
- `../MetaData/Documentation/ENVIRONMENT_URLS_REFERENCE.md` - Comprehensive URLs
- `../MetaData/Reference/ENVIRONMENT_URLS_GRID.csv` - CSV for team sharing
- `../MetaData/Scripts/` - Deployment and utility scripts
- `../MetaData/Configs/` - ECS task definitions and configs

## Agent Instructions

### üöÄ **ON AGENT CREATION - MANDATORY FIRST STEPS**
**CRITICAL**: When a new agent session starts, you MUST:
1. **Read and review ALL context files** to understand current backend state:
   - Read `.cursorrules` (root monorepo context)
   - Read `BE/.cursorrules` (this file - backend context)
   - Review `MetaData/Documentation/` for recent session documentation
   - Review `MetaData/Documentation/README.md` - Master documentation index
   - Review `MetaData/Documentation/AWS_INFRASTRUCTURE_DETAILS.md` - AWS infrastructure details
   - Review `MetaData/Documentation/Payments/PAYMENT_SYSTEM_IMPLEMENTATION.md` - Payment system documentation
   - Review `MetaData/Documentation/Database/SCHEMA_REFERENCE.md` - Database structure
   - Review `MetaData/Documentation/TROUBLESHOOTING.md` - Common issues and solutions
   - Check "Recent Changes" sections
2. **Understand current backend status** before starting any work:
   - Review "Current Status" section
   - Check deployment status and environment configuration
   - Review API structure and endpoints
   - Identify any ongoing work or pending tasks
   - Note any known issues or limitations
3. **Familiarize yourself with backend architecture**:
   - Understand .NET 8.0 project structure
   - Know database schema and Entity Framework setup
   - Understand deployment process (ECS, Docker, ECR)
   - Review AWS infrastructure configuration

### üìã **General Agent Guidelines**
- Always check context files for current project status
- Follow .NET 8.0 and ASP.NET Core best practices
- Maintain RESTful API design principles
- Document API changes in Swagger/OpenAPI
- Test changes with unit and integration tests
- Ensure database migrations are properly created

### ‚úÖ **TASK COMPLETION PROTOCOL - MANDATORY**
**CRITICAL**: For every task you start and complete, you MUST:
1. **Use `todo_write` tool** to track all tasks with clear status updates
2. **BUILD LOCALLY BEFORE PUSHING** - **MANDATORY**:
   - **ALWAYS run `dotnet build`** in the BE directory before committing/pushing
   - Verify build completes successfully with no errors
   - Run tests if applicable: `dotnet test`
   - Fix any build errors before pushing to repository
   - This prevents CI/CD failures and broken deployments
3. **Update context files IMMEDIATELY upon task completion**:
   - Update `BE/.cursorrules` "Recent Changes" section
   - Update root `.cursorrules` "Recent Changes" section
   - Update `CONTEXT_QUICK_REFERENCE.md` if applicable
   - Document in "Recent Changes" with:
     - ‚úÖ Status indicators
     - Clear descriptions of what was fixed/implemented
     - Technical details for future reference
     - Date and session information
4. **Commit context updates** to the BE repository:
   - All backend context updates ‚Üí commit to BE repository
   - Include context updates in the same commit as code changes when possible
5. **Provide summary** of what was accomplished for chat continuity

**Why This Matters**: This ensures that when a new agent session starts, the context contains complete, up-to-date information about recent backend work and current status. Without updating context files, new agents will be working with outdated information.

### üîß **CRITICAL UPDATE TRIGGERS**
**CRITICAL**: If any changes relate to the following, you MUST update context files:
- API design or endpoint changes
- Database schema or migrations
- Deployment processes or infrastructure
- Environment configuration
- Authentication/authorization changes
- New features or major refactoring

## Pieces MCP Integration

### Overview
Pieces MCP provides access to Long-Term Memory (LTM-2.7) engine, allowing agents to query workflow context, code snippets, notes, and activity history. This significantly improves agent effectiveness by providing access to your workflow history and saved context.

**Key Benefits:**
- **Context Continuity**: Agents understand recent work and decisions across sessions
- **Pattern Reuse**: Discover existing implementations and proven solutions
- **Decision Tracking**: Understand project evolution and documented challenges
- **Resource Discovery**: Access saved code snippets, bookmarks, and notes
- **Workflow Efficiency**: Faster problem-solving with historical context

### Prerequisites
- **PiecesOS**: Must be installed and running (check system tray/processes)
- **Long-Term Memory Engine (LTM-2.7)**: Must be enabled in PiecesOS
- **MCP Configuration**: Pieces MCP server must be configured in Cursor Settings
- **Tool Availability**: `ask_pieces_ltm` tool is automatically available in **ALL modes** (Auto, Agent, Manual) when MCP server is configured

**Setup Documentation**: See `MetaData/Documentation/Development/PIECES_MCP_INTEGRATION.md` for complete setup instructions.

**Note**: Pieces MCP works seamlessly in **Auto Mode** - no special mode selection required. The tool is automatically available when the MCP server is configured and running.

### Usage Guidelines

#### When to Use Pieces MCP

**1. Context Retrieval** - Understand previous work and decisions:
- "What was I working on yesterday?"
- "Show me recent authentication code changes"
- "What files did I modify last week?"
- "What was I doing with this file yesterday?"

**2. Code Pattern Discovery** - Find existing implementations:
- "Show examples of React Context usage in this project"
- "What was my last implementation of API error handling?"
- "Have I previously optimized rendering performance?"
- "Show me how I implemented authentication middleware"

**3. Decision Tracking** - Understand project evolution:
- "Track the evolution of the dashboard feature"
- "Review documented challenges with the payment system"
- "Show the decisions made around UI updates"
- "What architectural decisions were made for the microservices?"

**4. Resource Discovery** - Find saved resources:
- "Find recent bookmarks about Kubernetes"
- "What resources did I save recently related to Python decorators?"
- "Show notes taken about GraphQL in March"
- "What documentation did I bookmark about AWS ECS?"

**5. Code Review Context** - Understand feedback and changes:
- "Show code review comments related to database indexing"
- "Did we finalize naming conventions for the latest API endpoints?"
- "What feedback did I leave on recent pull requests?"
- "What issues were identified in the security audit?"

#### Effective Prompting Tips
- **Specify Timeframes**: "yesterday", "last week", "April 2nd through April 6th"
- **Mention Applications**: "Stack Overflow pages I visited on Chrome", "meeting notes from Notion"
- **Include Technical Keywords**: "JavaScript code related to API authentication", ".NET 8.0 migration patterns"
- **Reference Open Files**: "What was I doing with this file yesterday?"
- **Combine Parameters**: Mix timeframes, applications, and topics for precise queries

### Agent Workflow Integration

#### Automatic Usage in All Modes
**CRITICAL**: Pieces MCP works in **ALL modes** (Auto, Agent, Manual). The `ask_pieces_ltm` tool is automatically available when MCP server is configured.

**Best Practice**: Use Auto Mode for seamless integration - agent will automatically use Pieces MCP when appropriate.

#### On Agent Creation - MANDATORY
**CRITICAL**: When a new agent session starts, you MUST:

1. **ALWAYS Check Pieces MCP First** (MANDATORY):
   - **Attempt to use `ask_pieces_ltm` tool immediately** - it's a primary context source
   - If tool is available, use it for all context queries below
   - If tool is not available, log warning and continue with standard workflow
   - **NEVER skip Pieces MCP check** - always attempt usage first

2. **Query Recent Context** (MANDATORY if tool available):
   - **ALWAYS query**: "What was I working on in this project in the last 24 hours?"
   - **ALWAYS query**: "What recent changes were made to the authentication system?"
   - **ALWAYS query**: "Show me recent work on the payment service"
   - **ALWAYS query**: "What issues or bugs were recently fixed?"
   - Use these queries to understand project state before starting any work

3. **Understand Current State** (MANDATORY):
   - "What is the current deployment status?"
   - "What features are in progress?"
   - "What technical debt or known issues exist?"
   - "What recent security fixes were applied?"

#### Automatic Usage Triggers

**PRIMARY USE CASES - Use Pieces MCP (`ask_pieces_ltm` tool) when:**

1. ‚úÖ **When Stuck** - Query for similar problems and solutions:
   - Encountering an error or issue
   - Facing a problem without clear solution
   - Need to understand why something isn't working
   - Looking for troubleshooting approaches

2. ‚úÖ **Need Patterns** - Query for existing implementations:
   - Looking for code patterns or architectural patterns
   - Need examples of similar implementations
   - Want to follow established conventions
   - Seeking proven solutions

3. ‚úÖ **Task Could Benefit from Past Work** - Query for related context:
   - Starting a new task or feature (query for related previous work)
   - Need to understand project history and evolution
   - Understanding architectural decisions
   - Finding related code or documentation
   - Need context about why decisions were made

4. ‚úÖ **Work Completed Earlier in the Day** - Query for recent work:
   - User asking about work completed earlier today
   - Need to understand what was done recently
   - Looking for context about today's activities

5. ‚úÖ **References to People, Applications, or Research** - Query for specific context:
   - User references specific people by name
   - User mentions specific applications
   - User asks about research activities
   - Need context about conversations or interactions

#### User Rules for `ask_pieces_ltm` Tool

**CRITICAL**: Follow these rules when using the `ask_pieces_ltm` tool:

1. **When to Use**:
   - ‚úÖ User is asking about work completed earlier in the day
   - ‚úÖ User references names of specific people
   - ‚úÖ User mentions specific applications
   - ‚úÖ User asks about research activities

2. **Query Requirements** (MANDATORY):
   - **MUST specify time ranges** in queries (e.g., "today", "earlier today", "this morning", "last 24 hours")
   - **MUST include other suggested queries** when appropriate (e.g., related topics, follow-up questions)

3. **Source Assumptions**:
   - **If keyword 'researching' is used**: Assume primary application source is **Google Chrome**
   - **If a person is referenced**: Assume source is **Google Chrome** or **Google Chat**

4. **Tool Usage**:
   - When using `ask_pieces_ltm`, you are free to make multiple calls to the tool
   - Consider making follow-up queries based on initial results
   - Use time ranges and source hints to improve query accuracy

#### Using `create_pieces_memory` Tool

**Purpose**: Create persistent memories in Pieces LTM for important decisions, patterns, and context that future agent sessions should know.

**When to Use `create_pieces_memory`**:
- ‚úÖ **After Completing Significant Work** - Document important implementations, decisions, or solutions
- ‚úÖ **After Solving Complex Problems** - Save troubleshooting approaches and solutions
- ‚úÖ **After Making Architectural Decisions** - Document why decisions were made
- ‚úÖ **After Discovering Patterns** - Save proven patterns and best practices
- ‚úÖ **After Code Reviews or Feedback** - Document important feedback and changes
- ‚úÖ **After Major Refactoring** - Document structural changes and rationale

**What to Include in Memories**:
- **Summary**: Concise title describing the memory (1-2 sentences)
- **Detailed Narrative**: Complete story with background, thought process, what worked/didn't work, decisions made
- **Files**: List all relevant files involved (absolute paths)
- **External Links**: GitHub URLs, documentation links, articles consulted
- **Project Path**: Absolute path to project root
- **Context**: Why this memory is important for future sessions

**Best Practices**:
- Create memories for work that future agents will benefit from understanding
- Include enough context that someone reading it later understands the full picture
- Link to relevant files and external resources
- Use clear, descriptive summaries
- Document both successes and lessons learned

**Example Use Cases**:
- After implementing a new feature: Document the approach, challenges, and final solution
- After fixing a critical bug: Document the root cause, fix, and prevention strategies
- After architectural changes: Document the rationale and impact
- After performance optimizations: Document the approach and results

**Additional Triggers:**
- ‚úÖ **Starting a new task or feature** - Query for related previous work
- ‚úÖ **Encountering an error or issue** - Query for similar problems and solutions
- ‚úÖ **Need to understand project history** - Query for evolution and decisions
- ‚úÖ **Looking for existing patterns or solutions** - Query for implementations
- ‚úÖ **Understanding architectural decisions** - Query for documented choices
- ‚úÖ **Finding related code or documentation** - Query for saved resources

**Decision Flow (ALWAYS follow):**
1. Is `ask_pieces_ltm` tool available? ‚Üí **YES**: Use it immediately ‚Üí **NO**: Continue without (log warning)
2. **Am I stuck?** ‚Üí **YES**: Query LTM for solutions ‚Üí **NO**: Continue to next check
3. **Do I need patterns?** ‚Üí **YES**: Query LTM for implementations ‚Üí **NO**: Continue to next check
4. **Could this task benefit from understanding past work?** ‚Üí **YES**: Query LTM for related context ‚Üí **NO**: Continue
5. Starting new task? ‚Üí **YES**: Query LTM for related work ‚Üí **NO**: Continue

#### During Task Execution

**Before Starting Work** (MANDATORY):
1. **ALWAYS Query LTM First** for related previous work:
   - "Have I worked on similar [feature/task] before?"
   - "What patterns or solutions did I use for [similar requirement]?"
   - "Show me previous implementations of [component type]"
   - "How did I handle [similar requirement] in other services?"

2. **ALWAYS Check for Existing Solutions**:
   - "How did I solve [similar problem] before?"
   - "What approaches have been tried for [issue type]?"
   - "Are there existing patterns I should follow for [feature]?"
   - "What was my approach to [similar task]?"

**When Stuck** (MANDATORY):
**CRITICAL**: When stuck, ALWAYS query Pieces MCP FIRST before trying other approaches.

1. **ALWAYS Query LTM First** for solutions:
   - "How did I solve [similar problem] before?"
   - "Show me examples of [pattern/technique] I've used"
   - "What resources did I save about [topic]?"
   - "How did I handle [similar deployment/configuration issue]?"
   - "What approaches have been tried for [issue type]?"

2. **ALWAYS Find Related Context**:
   - "What documentation exists about [topic]?"
   - "Show me code snippets related to [feature]"
   - "What decisions were made about [architectural choice]?"
   - "How did I configure [service/tool] before?"

**When Needing Patterns** (MANDATORY):
**CRITICAL**: When you need patterns or examples, ALWAYS query Pieces MCP FIRST.

1. **Query for Implementation Patterns**:
   - "Show me examples of [pattern/technique] I've used in this project"
   - "What patterns did I use for [similar requirement]?"
   - "How did I implement [similar feature] before?"
   - "What architectural patterns have I used for [component type]?"

2. **Query for Code Examples**:
   - "Show me code snippets related to [feature/pattern]"
   - "What was my implementation approach for [similar task]?"
   - "How did I structure [similar component/service]?"

**When Task Could Benefit from Past Work** (MANDATORY):
**CRITICAL**: Before starting any task, evaluate if understanding past work would help. If yes, ALWAYS query Pieces MCP.

1. **Query for Related Previous Work**:
   - "Have I worked on similar [feature/task] before?"
   - "What was my approach to [similar task]?"
   - "What decisions were made about [related feature]?"
   - "How did I handle [similar requirement] in other services?"

2. **Query for Context and History**:
   - "What is the history of [feature/component]?"
   - "Why was [decision/approach] chosen?"
   - "What challenges were encountered with [related feature]?"
   - "What lessons were learned from [previous implementation]?"

**After Completing Work** (MANDATORY):
**CRITICAL**: After completing significant work, use `create_pieces_memory` to document important context.

1. **Evaluate if Memory is Needed**:
   - Was this a significant implementation or decision?
   - Will future agents benefit from understanding this work?
   - Does this solve a problem that might recur?
   - Is this a pattern or approach worth preserving?

2. **Create Memory if Appropriate**:
   - Use `create_pieces_memory` tool to document:
     - What was implemented/fixed/decided
     - Why decisions were made
     - What worked and what didn't
     - Relevant files and resources
     - Lessons learned
   - This helps future agent sessions understand context without needing to query

3. **Memory Content Guidelines**:
   - **Summary**: Clear, concise title (1-2 sentences)
   - **Detailed Narrative**: Complete story with full context
   - **Files**: All relevant files (absolute paths)
   - **External Links**: Documentation, GitHub URLs, articles
   - **Project Path**: Absolute path to project root

#### Optimized Query Templates

**Session Start Queries** (Use these immediately):
- "What was I working on in this project in the last 24 hours?"
- "What recent changes were made to [specific service/component]?"
- "What issues or bugs were recently fixed?"
- "What is the current deployment status?"

**Task Start Queries** (Use before starting any task):
- "Have I worked on similar [feature/task] before?"
- "What patterns or solutions did I use for [similar requirement]?"
- "Show me previous implementations of [component type]"
- "How did I handle [similar requirement] in other services?"

**Problem Solving Queries** (Use when stuck):
- "How did I solve [similar problem] before?"
- "What approaches have been tried for [issue type]?"
- "Show me examples of [pattern/technique] I've used"
- "What resources did I save about [topic]?"

### Troubleshooting

**MCP Server Not Running**:
- Verify PiecesOS is running (check system tray/processes)
- Check MCP server status in Cursor settings (should show "running")
- Restart MCP server if needed
- Verify LTM engine is enabled in PiecesOS

**Tool Not Available**:
- **Verify MCP Connection**: Check green dot in MCP settings (should show "running")
- **Check Mode**: Tool works in ALL modes (Auto, Agent, Manual) - no special mode required
- **Restart Cursor**: Sometimes requires IDE restart after MCP configuration
- **Verify PiecesOS**: Ensure PiecesOS is running and LTM is enabled
- **Note**: In Auto Mode, tool should be automatically available - if not, check MCP server status

**No Results from Queries**:
- Verify LTM is enabled
- Check PiecesOS is capturing your workflow
- Wait for indexing (LTM may need time to index recent activity)
- Check date ranges in queries reference timeframes with activity

**JSON Blob Error in MCP Settings**:
- **This is harmless**: Cursor's Settings UI doesn't recognize JSON-RPC success envelope
- **Ignore red JSON blobs** in MCP Settings view
- **Chat pane is source of truth** - if queries return formatted summaries, integration is working

**Documentation**: See `MetaData/Documentation/Development/PIECES_MCP_INTEGRATION.md` for complete troubleshooting guide.

## Architecture Overview

### System Architecture
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Frontend      ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ     Backend      ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ    Database     ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ                  ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ Angular 20.2.1  ‚îÇ    ‚îÇ .NET 8.0         ‚îÇ    ‚îÇ Aurora PostgreSQL‚îÇ
‚îÇ S3 + CloudFront ‚îÇ    ‚îÇ ECS Fargate      ‚îÇ    ‚îÇ Serverless v2   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ Docker + ALB     ‚îÇ    ‚îÇ (8 Schemas)     ‚îÇ
                       ‚îÇ SignalR Hubs     ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ 8 Microservices  ‚îÇ
                       ‚îÇ EventBridge      ‚îÇ
                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Microservices Architecture
All 8 microservices are independently deployable:
- Each service has its own Dockerfile and ECS task definition
- Each service uses its own PostgreSQL schema
- Services communicate via:
  - HTTP/REST (via ALB path-based routing)
  - EventBridge (event-driven architecture)
  - Service-to-service authentication (API key)
- Shared library (`AmesaBackend.Shared`) provides common functionality
- Redis caching (where required) for performance

### Request Flow
```
Client ‚Üí CloudFront /api/* ‚Üí ALB (path-based routing) ‚Üí ECS Task (microservice) ‚Üí .NET API ‚Üí Aurora PostgreSQL (schema-specific)
                                              ‚Üí SignalR Hub ‚Üí LongPolling Connection
                                              ‚Üí EventBridge ‚Üí Other Services
```

### Inter-Service Communication
- **HTTP/REST**: Services call each other via ALB using service-to-service authentication
- **EventBridge**: Event-driven communication for async operations
  - Event bus: `amesa-event-bus`
  - Event publisher: `EventBridgePublisher` in Shared library
  - Event schemas: Defined in `AmesaBackend.Shared/Events/EventSchemas.cs`
- **Service-to-Service Auth**: API key authentication via `ServiceToServiceAuthMiddleware`
  - API key stored in: `/amesa/prod/ServiceAuth/ApiKey` (SSM Parameter Store)

## Cross-Cutting Concerns

### Rate Limiting
- **Service**: `RateLimitService` (Redis-backed, circuit breaker protected)
- **Implementation**: Atomic increment-and-check pattern (prevents race conditions)
- **Cache Key Pattern**: `ratelimit:{key}` (Redis keys)
- **Fail-Open Behavior**: Default (allows requests if Redis fails), configurable to fail-closed
- **Circuit Breaker**: Protected by `CircuitBreakerService` (5 failures in 30 seconds threshold)

**Rate Limiting Rules**:

| Endpoint | Limit | Window | Key Pattern | Scope |
|----------|-------|--------|-------------|-------|
| Registration | 5 attempts | 1 hour | `registration:{ip}` | Per IP |
| Login | 5 attempts | 15 minutes | `login:{email}` | Per email |
| Resend Verification | 3 attempts | 1 hour | `resend-verification:{email}` | Per email |
| Forgot Password | 3 attempts | 1 hour | `password-reset:{email}` | Per email |
| Reset Password (Token) | 5 attempts | 1 hour | `password-reset-attempt:{token}` | Per token |
| Reset Password (IP) | 10 attempts | 1 hour | `password-reset-ip:{ip}` | Per IP |
| OAuth Exchange | 10 attempts | 15 minutes | `oauth-exchange:{ip}` | Per IP |
| Two-Factor Verify | 10 attempts | 1 minute | `2fa-verify:{userId}` | Per user |
| Account Deletion | 3 attempts | 1 hour | `account-deletion:{userId}` | Per user |
| Payment Processing | Variable | Variable | `payment:{userId}` | Service-specific |
| Payment Method Creation | 5 per hour | 1 hour | `payment-method:{userId}` | Per user |
| Transaction Queries | 100 per hour | 1 hour | `transaction-query:{userId}` | Per user |

### Circuit Breaker Patterns
- **Service**: `CircuitBreakerService` (Polly v8.4.2)
- **Configuration**:
  - Failure Threshold: 5 failures
  - Duration of Break: 30 seconds
  - Sampling Duration: 30 seconds
- **Operations Protected**:
  - `RateLimit_Redis` - Rate limiting Redis operations
  - `AccountLockout_Redis` - Account lockout Redis operations
- **Fail-Open Behavior**: Default (allows operations if circuit breaker opens)
- **Fail-Closed Configuration**: Configurable via `SecuritySettings:{Service}FailClosed`
- **Metrics**: Success/failure counters, periodic logging, high failure rate alerting

### Health Check Implementations
- **Generic Health Endpoint**: `/health` (all services)
  - Returns: `{ "status": "Healthy|Degraded|Unhealthy" }`
  - Used by: ALB target groups for health monitoring
  - Checks: Basic service availability
- **Service-Specific Health Checks**:
  - `/health/notifications` - Notification service detailed health
    - Checks: `basic`, `email`, `sms`, `webpush`, `telegram`
    - Status Codes: 200 (Healthy/Degraded), 503 (Unhealthy)
    - Dependencies: Database, Redis, AWS SES, SNS, external services
- **Health Check Response Format**:
  ```json
  {
    "status": "Healthy|Degraded|Unhealthy",
    "checks": {
      "basic": { "status": "Healthy", "description": "Service is running" },
      "database": { "status": "Healthy", "description": "Database connection OK" },
      "redis": { "status": "Healthy", "description": "Redis connection OK" }
    }
  }
  ```

### Error Handling Patterns
- **Global Error Handler**: `ErrorHandlerMiddleware` (shared middleware)
- **Error Response Format**: `StandardApiResponse<object>` with `StandardErrorResponse`
  ```json
  {
    "success": false,
    "error": {
      "code": "ERROR_CODE",
      "message": "Human-readable message",
      "details": {}
    }
  }
  ```
- **Error Code Mapping**:
  - `ApiException` (validation) ‚Üí `VALIDATION_ERROR`
  - `ApiException` (other) ‚Üí `API_ERROR` or `ReferenceErrorCode`
  - `CustomFaultException` ‚Üí Status code string
  - `UnauthorizedAccessException` ‚Üí `AUTHENTICATION_ERROR`
  - `KeyNotFoundException` ‚Üí `NOT_FOUND`
  - `DbException` ‚Üí `DATABASE_ERROR`
  - Default ‚Üí `INTERNAL_ERROR`
- **Error Logging**: All errors logged with context (sessionId, request body, stack trace)
- **Exception Details**: Configurable via `RestExceptionDetails:showExceptionDetails` (default: false)

### Caching Strategies
- **Redis Cache**: Distributed cache via `ICache` interface (StackExchange.Redis)
- **Cache Key Patterns**:
  - Houses: `houses_*` (pattern-based invalidation)
  - Translations: `translation_{language}_{key}`
  - User preferences: `user_prefs_{userId}`
  - Email verification: `email_verified:{userId}` (5 min TTL)
  - Rate limiting: `ratelimit:{key}`
  - Account lockout: `account_locked:{email}` (15 min TTL)
- **Cache TTL Values**:
  - Houses list: 5 minutes (in-memory), 30 minutes (localStorage frontend)
  - Individual houses: 5 minutes (in-memory), 1 hour (localStorage frontend)
  - Translations: 1 hour
  - Email verification status: 5 minutes
  - Rate limiting: Variable (matches rate limit window)
- **Cache Invalidation**:
  - Time-based: TTL expiration
  - Event-based: EventBridge events trigger cache invalidation
  - Manual: Service-specific cache invalidation methods
- **Fail-Open Strategy**: Services continue with database fallback if Redis fails
- **Services Using Redis**: Auth, Lottery, Content, Payment (required in production)

### Security Headers
- **Middleware**: `SecurityHeadersMiddleware` (shared middleware)
- **Headers Set**:
  - `X-Frame-Options: DENY` - Prevents clickjacking
  - `X-Content-Type-Options: nosniff` - Prevents MIME type sniffing
  - `X-XSS-Protection: 1; mode=block` - XSS protection
  - `Referrer-Policy: strict-origin-when-cross-origin` - Referrer policy
  - `Permissions-Policy: geolocation=(), microphone=(), camera=()` - Feature permissions
  - `Content-Security-Policy` - CSP policy (configured for SignalR WebSocket support)
  - `Strict-Transport-Security` - HSTS (HTTPS only, production)
- **Applied To**: All microservices via shared middleware

### CORS Configuration
- **Configuration**: Per-service CORS configuration in `Program.cs`
- **Allowed Origins**: Environment-specific (production CloudFront URL, localhost for dev)
- **Allowed Methods**: GET, POST, PUT, DELETE, OPTIONS, PATCH
- **Allowed Headers**: Content-Type, Authorization, X-Requested-With
- **Credentials**: Supported (cookies, authorization headers)

### Request/Response Logging
- **Middleware**: 
  - `RequestResponseLoggingMiddleware` - Basic request/response logging
  - `AMESASerilogScopedLoggingMiddleware` - Structured logging with Serilog
- **What Gets Logged**:
  - Request: Method, path, query params, headers (sanitized), body (sanitized)
  - Response: Status code, headers, body (sanitized)
  - Context: User ID, session ID, IP address, timestamp
- **PII Sanitization**: Passwords, tokens, sensitive data removed from logs
- **Log Levels**: Debug, Information, Warning, Error, Fatal
- **Log Retention**: CloudWatch logs (configurable retention period)

### Retry Policies
- **HTTP Client Retries**: Polly-based retry policies for inter-service communication
- **Retry Configuration**:
  - Max Retries: 3 (configurable)
  - Backoff Strategy: Exponential backoff (1s, 2s, 4s)
  - Retryable Errors: Transient network errors, timeout errors, 5xx server errors
  - Non-Retryable Errors: 4xx client errors (except 429 rate limit)
- **EventBridge Retries**: 
  - Max Retries: 3 (configurable via `EventBridge:MaxRetries`)
  - Retry tracking in Redis cache
  - Prevents infinite retries
- **Frontend Retry**: Automatic retry with exponential backoff for network errors (via `RetryService`)

### Secrets Management
- **AWS Secrets Manager**: Used for sensitive credentials in production
  - **OAuth Secrets** (Auth Service):
    - Google OAuth: `amesa-google_people_API` (contains `ClientId`, `ClientSecret`, `RecaptchaSiteKey`, `RecaptchaProjectId`, `RecaptchaMinScore`)
    - Meta OAuth: `amesa-meta-oauth` (contains `AppId`, `AppSecret`)
    - Loading method: `LoadOAuthSecretsFromAws()` extension method in `AwsSecretsConfiguration.cs`
    - Format: JSON objects with property names matching configuration keys
    - Region: Configurable via `Aws:Region` config or `AWS_REGION` env var (default: `eu-north-1`)
  - **Notification Secrets** (Notification Service):
    - Loading method: `LoadNotificationSecretsFromAws()` extension method
    - Location: `BE/AmesaBackend.Notification/Configuration/AwsSecretsConfiguration.cs`
  - **Payment Secrets** (Payment Service):
    - Loading method: `LoadPaymentSecretsFromAws()` extension method
    - Location: `BE/AmesaBackend.Payment/Configuration/PaymentSecretsConfiguration.cs`
  - **Error Handling**: Graceful degradation - logs warnings if secrets not found, continues with local config
  - **Production Only**: Secrets loading only occurs in production environment (`IsProduction()` check)
- **AWS SSM Parameter Store**: Used for service-to-service authentication
  - **Service Auth API Key**: `/amesa/prod/ServiceAuth/ApiKey`
  - **Usage**: Injected via ECS task definition secrets (e.g., `lottery-task-def.json`, `payment-task-def.json`)
  - **JWT Secret Key**: Also loaded from SSM Parameter Store via ECS task definition
- **Secret Formats**:
  - JSON format for complex secrets (OAuth credentials)
  - Plain text for simple secrets (API keys, JWT secrets)
- **Loading Pattern**: Extension methods on `IConfigurationBuilder` that add secrets to in-memory configuration collection

### Database Connection Patterns
- **Connection Pooling** (PostgreSQL/Npgsql):
  - **MaxPoolSize**: 100 connections
  - **MinPoolSize**: 10 connections
  - **ConnectionLifetime**: 300 seconds (5 minutes)
  - **CommandTimeout**: 30 seconds
  - **ConnectionTimeout**: 15 seconds
  - Configuration: Set via `NpgsqlConnectionStringBuilder` in `Program.cs` (e.g., `BE/AmesaBackend.Notification/Program.cs`)
- **EF Core Retry Policies**:
  - **Max Retries**: 3 attempts
  - **Max Retry Delay**: 30 seconds
  - **Error Codes**: All transient errors (null `errorCodesToAdd` means all)
  - Configuration: `EnableRetryOnFailure()` in `UseNpgsql()` options
  - Location: Configured per service in `Program.cs` database setup
- **Transaction Management**:
  - **Default Isolation Level**: READ COMMITTED (PostgreSQL default)
  - **Explicit Transactions**: Used for multi-step operations (e.g., ticket purchases, payment processing)
  - **Transaction Scope**: Typically scoped to service method execution
- **Connection String Sourcing**:
  - Primary: Environment variable `ConnectionStrings__DefaultConnection` or `ConnectionStrings:DefaultConnection` in config
  - Fallback: `appsettings.json` `ConnectionStrings:DefaultConnection`
  - Schema-Specific: Each service uses its own schema (e.g., `amesa_auth`, `amesa_lottery`, `amesa_notification`)
- **Development vs Production**:
  - Development: SQLite with file-based database (`appsettings.Development.json`)
  - Production: Aurora PostgreSQL Serverless v2 with connection pooling

### Monitoring & Observability
- **CloudWatch Logs**:
  - **Log Groups**: `/ecs/{service-name}` (e.g., `/ecs/amesa-auth-service`, `/ecs/amesa-lottery-service`)
  - **Logging Framework**: Serilog with CloudWatch sink
  - **Log Levels**: Information, Warning, Error, Critical
  - **Retention**: Configurable per log group (typically 30 days)
  - **Structured Logging**: JSON format with context (request ID, user ID, session ID)
- **CloudWatch Metrics**:
  - **Service**: `CloudWatchMetricsService` (e.g., in Notification service)
  - **Custom Metrics**: Application-specific metrics (e.g., notification send counts, error rates)
  - **Auto Metrics**: ECS service metrics (CPU, memory, network) and ALB metrics (request count, latency, error rates)
  - **Namespace**: Service-specific namespaces (e.g., `Amesa/Notification`)
  - **CloudWatch Client**: `IAmazonCloudWatch` singleton registered per service
- **AWS X-Ray** (Distributed Tracing):
  - **Status**: Currently commented out/removed in microservices (see `Program.cs` files)
  - **Previous Implementation**: `XRayExtensions` class for distributed tracing setup
  - **Note**: Tracing may be re-enabled in future for production observability
- **Health Checks**:
  - **Generic Endpoint**: `/health` (standard ASP.NET Core health checks)
  - **Service-Specific**: `/health/notifications`, `/health/captcha`, etc.
  - **Checks**: Database connectivity, external service availability (SNS, SES, etc.)
  - **Response Format**: JSON with status (`Healthy`, `Degraded`, `Unhealthy`) and details
- **SNS Alerts**:
  - **Topic**: `AmesaAlerts` (configured in AWS infrastructure)
  - **Usage**: Critical error notifications, system alerts
  - **Integration**: Via AWS SDK `IAmazonSimpleNotificationService`

### Validation Patterns
- **Data Annotations**: Primary validation method on DTOs
  - `[Required]` - Field is required
  - `[EmailAddress]` - Email format validation
  - `[StringLength(min, max)]` - String length validation
  - `[Range(min, max)]` - Numeric range validation
  - `[RegularExpression]` - Pattern matching
- **Custom Validators**:
  - `PasswordValidatorService` - Password strength validation
    - Minimum 8 characters
    - At least one uppercase letter
    - At least one lowercase letter
    - At least one digit
    - At least one special character
    - Not in common passwords list (100+ weak passwords)
    - Password history check (last 5 passwords, configurable)
    - Breach checking (optional, via `IPasswordBreachService`)
- **Model State Validation**: Automatic validation via `[ApiController]` attribute
- **Business Rule Validation**: Custom validation in services (e.g., participant cap checks)

### Background Services
- **SessionCleanupService** (Auth Service):
  - Purpose: Clean up expired user sessions
  - Schedule: Periodic cleanup (configurable interval)
  - Location: `BE/AmesaBackend.Auth/Services/SessionCleanupService.cs`
  
- **PasswordHistoryCleanupService** (Auth Service):
  - Purpose: Clean up old password history records
  - Schedule: Periodic cleanup (configurable interval)
  - Location: `BE/AmesaBackend.Auth/BackgroundServices/PasswordHistoryCleanupService.cs`
  
- **NotificationQueueProcessor** (Notification Service):
  - Purpose: Process queued notifications from database
  - Schedule: Continuous processing with configurable delay
  - Location: `BE/AmesaBackend.Notification/Services/NotificationQueueProcessor.cs`
  
- **NotificationArchiveBackgroundService** (Notification Service):
  - Purpose: Archive old notifications
  - Schedule: Periodic archiving (configurable interval)
  - Location: `BE/AmesaBackend.Notification/Services/NotificationArchiveBackgroundService.cs`
  
- **EventBridgeEventHandler** (Notification Service):
  - Purpose: Handle EventBridge events for notifications
  - Schedule: Event-driven (triggers on EventBridge events)
  - Location: `BE/AmesaBackend.Notification/Handlers/EventBridgeEventHandler.cs`
  
- **LotteryCountdownService** (Lottery Service):
  - Purpose: Calculate and broadcast lottery countdown updates
  - Schedule: Updates every 1 second for active lotteries
  - Location: `BE/AmesaBackend.Lottery/Services/LotteryCountdownService.cs`
  - Broadcasts: `CountdownUpdated` events via SignalR
  
- **ReservationCleanupService** (Lottery Service):
  - Purpose: Clean up expired ticket reservations
  - Schedule: Periodic cleanup (configurable interval)
  - Location: `BE/AmesaBackend.Lottery/Services/ReservationCleanupService.cs`
  
- **TicketQueueProcessorService** (Lottery Service):
  - Purpose: Process queued ticket creation requests
  - Schedule: Continuous processing with configurable delay
  - Location: `BE/AmesaBackend.Lottery/Services/TicketQueueProcessorService.cs`
  
- **InventorySyncService** (Lottery Service):
  - Purpose: Synchronize inventory data between services
  - Schedule: Periodic sync (configurable interval)
  - Location: `BE/AmesaBackend.Lottery/Services/InventorySyncService.cs`

### Service Registration Patterns
- **Extension Method Pattern**: All service registration is organized via extension methods in `Configuration/` folders
  - **Naming Convention**: `Add{ServiceName}{Feature}()` (e.g., `AddAuthServices()`, `AddAuthSwagger()`, `AddAuthControllers()`)
  - **Purpose**: Encapsulates service registration logic, keeps `Program.cs` clean and readable
  - **Location**: Each microservice has its own `Configuration/` folder with extension methods
- **Service Registration Methods**:
  - `AddAuthControllers()` - Configures controllers with camelCase JSON serialization and custom ModelState validation
  - `AddAuthSwagger()` - Configures Swagger/OpenAPI documentation
  - `AddAuthDatabase()` - Configures Entity Framework with PostgreSQL connection pooling
  - `AddAuthCors()` - Configures CORS policy for frontend
  - `AddAuthServices()` - Registers all application services (security, auth, AWS, infrastructure)
  - `AddAuthForwardedHeaders()` - Configures forwarded headers for load balancer/proxy
  - `AddJwtAuthentication()` - Configures JWT authentication
  - `AddAuthAuthorization()` - Configures authorization policies
  - `UseAuthSerilog()` - Configures Serilog logging
  - `UseAuthKestrel()` - Configures Kestrel HTTPS (development only)
  - `UseAuthMiddleware()` - Configures middleware pipeline
- **Service Lifetime Patterns**:
  - **Singleton**: AWS service clients (`IAmazonRekognition`, `IAmazonSES`, `IAmazonSNS`), `ICircuitBreakerService`
  - **Scoped**: Application services (repositories, business logic), `IRateLimitService`, `IAccountLockoutService`
  - **Transient**: Not commonly used (default for most services)
- **Dependency Resolution**:
  - Circular dependencies handled with `Lazy<T>` pattern (e.g., `AccountRecoveryService` and `PasswordResetService`)
  - Shared library services registered via `AddAmesaBackendShared()` extension method
  - HttpClient registration with configuration (e.g., `NotificationPreferencesSyncService`)

### Swagger/OpenAPI Configuration
- **Setup**: Configured via `AddAuthSwagger()` extension method in `Configuration/SwaggerConfiguration.cs`
- **OpenAPI Info**:
  - Title: Service-specific (e.g., "Amesa Auth API")
  - Version: "v1"
  - Description: Service description
  - Contact: Support email and name
- **Security Scheme**:
  - **Bearer Token Authentication**: JWT token via Authorization header
  - Scheme: "Bearer"
  - Description: "JWT Authorization header using the Bearer scheme. Example: \"Authorization: Bearer {token}\""
  - Location: Header
- **Security Requirements**: All endpoints require Bearer token authentication
- **Endpoints**:
  - Swagger UI: `/swagger` (development) or `/swagger/index.html`
  - OpenAPI JSON: `/swagger/v1/swagger.json`
- **Configuration Location**: `BE/AmesaBackend.{Service}/Configuration/SwaggerConfiguration.cs`
- **Usage**: Enabled in development, can be conditionally enabled in production

### Logging Configuration Patterns
- **Framework**: Serilog with structured logging
- **Configuration Method**: `UseAuthSerilog()` extension method in `Configuration/LoggingConfiguration.cs`
- **Configuration Sources**:
  - Primary: `appsettings.json` (via `ReadFrom.Configuration()`)
  - Environment-specific: `appsettings.{Environment}.json`
- **Sinks**:
  - **Console**: Development and production (via `WriteTo.Console()`)
  - **File**: Development only (`logs/auth-.txt` with daily rolling)
  - **CloudWatch**: Production (configured via `appsettings.json` Serilog settings)
- **Log Context Enrichment**: `Enrich.FromLogContext()` for request/user context
- **Log Levels**: Configured via `appsettings.json` (Information, Warning, Error, Critical)
- **Structured Logging**: JSON format with properties (e.g., `Log.Information("User logged in: {UserId}", userId)`)
- **Graceful Shutdown**: `ConfigureGracefulShutdown()` ensures logs are flushed on application shutdown
- **Log Location**: `BE/AmesaBackend.{Service}/Configuration/LoggingConfiguration.cs`
- **Best Practices**:
  - Use structured logging with properties, not string interpolation
  - Include context (request ID, user ID, session ID) via log context
  - Sanitize PII in logs (middleware handles this)

### Application Bootstrap Patterns
- **Program.cs Structure** (Top-to-bottom execution order):
  1. **Configuration Setup**: Google credentials, Serilog logging
  2. **Forwarded Headers**: Load balancer/proxy configuration
  3. **Controllers**: JSON serialization (camelCase), ModelState validation
  4. **Swagger/OpenAPI**: API documentation setup
  5. **Database**: Entity Framework with connection pooling
  6. **Secrets Loading**: AWS Secrets Manager (production only)
  7. **Authentication**: JWT configuration
  8. **OAuth**: Google and Meta OAuth (if configured)
  9. **Authorization**: Policy configuration
  10. **CORS**: Frontend origin configuration
  11. **Services**: All application services registration
  12. **Kestrel**: HTTPS configuration (development only)
  13. **Middleware Pipeline**: Forwarded headers, HTTPS, Swagger, CORS, shared middleware, security, routing, auth, health checks
  14. **Database Creation**: Development only (ensures database exists)
  15. **Graceful Shutdown**: Log flushing on shutdown
- **Error Handling**: Try-catch-finally block with Serilog fatal logging
- **Partial Program Class**: `public partial class Program { }` for test project access
- **Pattern**: Extension methods keep `Program.cs` clean and maintainable
- **Location**: `BE/AmesaBackend.{Service}/Program.cs`

## Business Context
- **4Wins Model**: Property lottery platform
- **Legal Compliance**: Gaming regulations, responsible gambling
- **Payment Processing**: Secure Stripe integration
- **Multi-language**: Internationalization support
- **Real-time Features**: Live lottery updates via SignalR
- **Identity Verification**: KYC/AML compliance

## Cursor Cost Optimization Refactoring - Backend Status

**Overall Progress**: Phases 1-3 Complete ‚úÖ (Backend refactoring 100% complete)

### Phase 1: Program.cs Configuration Extraction ‚úÖ **COMPLETE**
- **Status**: ‚úÖ Complete
- **Files Refactored**: 
  - `BE/AmesaBackend.Auth/Program.cs` - Reduced from 982 lines to 78 lines
  - `BE/AmesaBackend/Program.cs` - Reduced from 773 lines to 98 lines
- **Configuration Classes Created**: 9 dedicated configuration classes per service
  - GoogleCredentialsConfiguration, LoggingConfiguration, ServiceConfiguration, SwaggerConfiguration
  - DatabaseConfiguration, AwsSecretsConfiguration, JwtConfiguration, AuthenticationConfiguration, MiddlewareConfiguration
- **Expected Savings**: $25-35/month ‚úÖ **ACHIEVED**
- **Impact**: Prevents git commit spirals, reduces context by ~1,100 lines per request

### Phase 2: HousesController Split ‚úÖ **COMPLETE**
- **Status**: ‚úÖ Complete
- **Files Refactored**: 
  - `BE/AmesaBackend.Lottery/Controllers/HousesController.cs` - Reduced from 1,081 lines to 478 lines
- **New Controllers Created**: 
  - HousesSearchController (GetHouses endpoint)
  - HousesFavoritesController (favorites endpoints)
  - HousesRecommendationsController (GetRecommendedHouses)
  - HousesStatsController (stats endpoints)
- **Services Created**: 
  - HouseCacheService (cache invalidation logic)
- **Expected Savings**: $12-18/month ‚úÖ **ACHIEVED**
- **Impact**: Reduces context by ~700 lines per request

### Phase 3: AuthService Split ‚úÖ **COMPLETE**
- **Status**: ‚úÖ Complete
- **Files Refactored**: 
  - `BE/AmesaBackend.Auth/Services/AuthService.cs` - Reduced from 963 lines to 543 lines
- **New Services Created**: 
  - TokenService (token generation/validation)
  - SessionService (session management)
  - EmailVerificationService (email verification)
  - PasswordResetService (password reset flow)
- **Expected Savings**: $10-15/month ‚úÖ **ACHIEVED**
- **Impact**: Reduces context by ~600 lines per request

### Backend Refactoring Summary
- **Total Lines Reduced**: ~2,400 lines across 3 major files
- **New Files Created**: 13 new controllers/services
- **Total Savings**: $47-68/month from backend refactoring
- **Status**: ‚úÖ **100% Complete** - All backend phases done

**Reference**: See `MetaData/Documentation/COST_OPTIMIZATION_REPORT.md` for complete analysis

---

## OAuth Provider Implementation Status

### Fully Implemented OAuth Providers

**Google OAuth** ‚úÖ
- **Status**: Fully implemented and working in production
- **AWS Secrets Manager**: Secret `amesa-google_people_API` (default SecretId)
- **Backend Endpoints**: 
  - `GET /api/v1/oauth/google` - Initiate Google OAuth
  - `GET /api/v1/oauth/google-callback` - Google OAuth callback
- **Configuration**: `Authentication:Google:SecretId` (defaults to `amesa-google_people_API`)
- **Secret Format**: JSON with `ClientId`, `ClientSecret`, `RecaptchaSiteKey`, `RecaptchaProjectId`, `RecaptchaMinScore`
- **Database Support**: `AuthProvider.Google` enum, `provider_id` column
- **Frontend**: `loginWithGoogle()` method and Google login button

**Meta OAuth** ‚úÖ
- **Status**: Fully implemented, configured and ready for production
- **AWS Secrets Manager**: Secret `amesa-meta-oauth`
- **Secret ARN**: `arn:aws:secretsmanager:eu-north-1:129394705401:secret:amesa-meta-oauth-nd63xt`
- **Backend Endpoints**: 
  - `GET /api/v1/oauth/meta` - Initiate Meta OAuth
  - `GET /api/v1/oauth/meta-callback` - Meta OAuth callback
- **Configuration**: `Authentication:Meta:SecretId` (defaults to `amesa-meta-oauth`)
- **Secret Format**: JSON with `AppId` and `AppSecret` keys
- **Facebook Developer Console**: Redirect URI `https://dpqbvdgnenckf.cloudfront.net/api/v1/oauth/meta-callback` configured
- **Database Support**: `AuthProvider.Meta` enum, `provider_id` column
- **Frontend**: `loginWithMeta()` method and Meta login button

### Partially Implemented OAuth Providers

**Apple OAuth** ‚ö†Ô∏è
- **Status**: Frontend-only implementation
- **Frontend**: `loginWithApple()` method and Apple login button exist
- **Backend**: No OAuth endpoints implemented (no `/api/v1/oauth/apple` or `/api/v1/oauth/apple-callback`)
- **Database**: `AuthProvider.Apple` enum exists but not used
- **Note**: Backend implementation required for full functionality

### Not Implemented OAuth Providers

**Twitter OAuth** ‚ùå
- **Status**: Not implemented
- **Database**: `AuthProvider.Twitter` enum exists but no implementation
- **Frontend**: No Twitter login button or method
- **Backend**: No OAuth endpoints

### Shared OAuth Infrastructure
- **Token Exchange**: `POST /api/v1/oauth/exchange` - Shared endpoint for all OAuth providers
- **User Creation**: `CreateOrUpdateOAuthUserAsync()` supports Google and Meta providers
- **OAuth Callback Component**: Frontend component handles all OAuth callbacks
- **Database Schema**: `users` table has `auth_provider` (enum) and `provider_id` (string) columns

## Recent Changes Summary

| Change | Status | Date | Key Points |
|--------|--------|------|------------|
| **Pieces MCP Integration** | ‚úÖ Integrated | 2025-01-25 | LTM engine for agent context, workflow history access |
| **Admin Panel Security** | ‚úÖ Production Ready | 2025-01-25 | All critical issues fixed, rate limiting, BCrypt, secure sessions |
| **Auth Security Audit** | ‚úÖ Complete | 2025-01-25 | All critical/high issues resolved, excellent security posture |
| **ECS Deployment Fix** | ‚úÖ Fixed | 2025-01-25 | SSM parameter `/amesa/prod/ServiceAuth/ApiKey` created |
| **Meta OAuth** | ‚úÖ Ready | 2025-01-25 | Fully integrated with AWS Secrets Manager, ready for production |
| **Payment Service** | ‚úÖ Stabilized | 2025-01-25 | Stripe JSON format, IRateLimitService registration, Redis config fixed |
| **CI/CD Workflow** | ‚úÖ Updated | 2025-01-25 | Test failures no longer block deployment |
| **Test Fixes** | ‚úÖ Fixed | 2025-01-25 | 97 passed, 0 failed, 5 skipped |
| **Multi-Channel Notifications** | ‚úÖ Deployed | 2025-01-25 | Complete implementation, ALB routing configured, production-ready |
| **Favorites & Redis** | ‚úÖ Fixed | 2025-01-25 | UserPreferencesService registration, Redis requirement enforced |
| **reCAPTCHA Enterprise** | ‚úÖ Complete | 2025-01-25 | Enterprise API, metrics tracking, monitoring endpoint |
| **Translation System** | ‚úÖ Complete | 2025-01-25 | 507 keys √ó 4 languages, all scripts organized |
| **Database Seeding** | ‚úÖ Complete | 2025-01-25 | Production database seeded, schema alignment fixed |
| **100% Complete Audit** | ‚úÖ Approved | 2025-01-25 | All functionality complete, production-ready |

**Detailed Documentation**: See `MetaData/Documentation/` for complete audit reports and session documentation.

## Previous Work (2025-10-08)
- ‚úÖ Configured GitHub Actions CI/CD pipeline
- ‚úÖ Set up ECS/ECR deployment flow
- ‚úÖ Implemented multi-environment strategy
- ‚úÖ Added health check endpoints
- ‚úÖ Configured database authentication

## üìö **Session Documentation**
**Latest Session**: 100% Complete Audit (2025-01-25)
- **Final Audit**: `BE/100_PERCENT_COMPLETE_AUDIT.md` - Complete 100% audit report
- **Status Summary**: `BE/FINAL_STATUS_SUMMARY.md` - Quick status summary
- **Status**: ‚úÖ Production Ready - All critical functionality complete
- **Previous Sessions**: See `MetaData/Documentation/README.md` for complete documentation structure

## 100% Complete Audit (2025-01-25)
‚úÖ **PRODUCTION READY** - All development work, gap fixes, and integration tasks completed

| Area | Status | Details |
|------|--------|---------|
| **Translation Keys** | ‚úÖ 100% | 78 keys √ó 4 languages = 312 entries (Payment: 58 keys, Common: 20 keys) |
| **Frontend Services** | ‚úÖ 100% | All 7 services: TwoFactorService, DrawsService, SecurityQuestionsService, PaymentService, LotteryResultsService, AuthService, WebPushService |
| **Frontend Components** | ‚úÖ 100% | PaymentMethodSelectionModalComponent, Dashboard Accordion Components (all sub-components) |
| **API Documentation** | ‚úÖ 100% | 22 endpoints documented (Payment: 12, Lottery: 2, Auth: 8) |
| **Error Handling** | ‚úÖ 100% | Comprehensive error handling throughout |
| **Accessibility** | ‚úÖ 100% | Full ARIA, keyboard navigation, screen reader support |
| **Code Quality** | ‚úÖ Excellent | Well-structured, proper error handling, type safety (90%+) |
| **Documentation** | ‚úÖ Complete | Audit reports: `BE/100_PERCENT_COMPLETE_AUDIT.md`, `BE/FINAL_STATUS_SUMMARY.md`, `BE/API_ENDPOINT_VERIFICATION_RESULTS.md` |
| **SQL Scripts** | ‚úÖ Deployed | Payment translations, Common translation keys |

**Recommendation**: ‚úÖ **APPROVED FOR PRODUCTION**

---
**Last Updated**: 2025-01-25
**Context Version**: 2.8.0 (100% completion audit added)
**Note**: Update this file immediately after API, schema, infra, or deployment changes; add dated "Recent Changes" entries for any 2025 work not yet captured.

